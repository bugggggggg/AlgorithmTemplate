1. 在加倍数据（比如把一个数组复制两倍，或者题目给了n，实际有2n数据）时，注意数组大小有没有开对，即使是tle也可能是数组开小了。
2. 数据范围给的边界数据都可以拿来测一下。
3. 看看有没有地方爆了int
4. 逆序对是可以局部求解的，可以分开考虑两两之间的贡献。
5. 数论分块：在[l,n/(n/l)]内的i，n/i的值都相等，并且n%i是等差数列，公差为(n/l)。
6. 一些离散数据相关的题里，在清空数据或用离散的值统计答案时，注意有没有新的值产生。
     如[https://codeforces.com/contest/1471/problem/D](https://codeforces.com/contest/1471/problem/D)这题里，1可能是原来没有，而过程中产生的。
7. 找中位数可以用二分，二分一个w，大于等于w的记为1，其余记为-1，只要区间和大于等于0，就是满足的。
     因为中位数一定是原本的数，所以离散化后中位数只可能取1---n。
8. 
```c
树状数组上倍增找第k个1要先找第k个1左边位置，然后加1.
int BS(int k)
{
	k--;
	int p=0;
	for(int i=20;i>=0;i--)
		if((1<<i)+p<=N&&sum[(1<<i)+p]<=k)
			k-=sum[(1<<i)+p],p+=(1<<i);
	return p+1;
}
```
9. 历史版本（可持久化数据结构）有离线的一个思路：把每个版本看成节点，版本迁移看成边，然后用数据结构维护遍历和回溯的过程。

10. multiset和set的iterator可以用++，- -来移动。（ 有时候可以用来代替平衡树）

11. double被卡精度时可以开long double（用  **%Lf** 读入）

12. 边权转成点权：可以用一个点把边分成两段，然后这个点就代表了这条边。

13. 能合并的东西（如求和，最大值，线性基等）可以考虑用倍增优化（预处理出 i 往前 2^p这一段的值）

14. 求树上一段链的信息，除了类似倍增lca一样，也可以模仿st表的思路，把链划成两段（要找上面一段的起点可以类似倍增lca往上走），这么做的好处是在合并复杂度较大的时候，可以把一个log的复杂度转移掉。

15. [最小割的可行边与必须边](https://www.cnblogs.com/dugudashen/p/6228304.html)。

    **求一组最小割的方案**：现在原图跑最大流，然后把满流边边权改为1，其余改为无穷，再跑一次最大流，这时被割的边就是一组方案。

    **最小割的可行边**：被某一种最小割方案包含的边。

    充要条件：

    　　1.满流。

    　　2.在残余网络中找不到入点到出点的路径。

    若不满流显然可以找到另一条更小的满流的限制流量的边。

    若满流但在残余网络中能找到入点到出点的路径，那么需要同时割掉这条边和残余网络中路径上某条边才能实现“割”，而这两条边上的流量和一定等于其他某条或某几条满流的边的流量和，否则可以继续增广，又因为位于残余网络上的那条边一定不满流，所以这种割法不是最小割。

    求法：

    在残余网络中tarjan求SCC，入出两点在同一SCC中说明残余网络中存在入点到出点的路径。

    由于该边满流，它的反向边一定存在于残余网络中，反向边与其他入点到出点的路径会构成SCC。



    **最小割的必须边**（不考虑容量为0的边）：一定在最小割中的边。
    
    充要条件：
    
    　　1.满流。
    
    　　2.残余网络中源点能到入点，出点能到汇点。
    
    若不满流显然可以找到另一条更小的满流的限制流量的边。
    
    若满流但在残余网络中源点不能到入点或出点不能到汇点，那么在每条单独路径上一定都存在一条满足最小割可行边的边（容量为0阻断路径且没有其他路径），割掉这条可行边是等价的。
    
    必须边的另一种理解是扩大容量后能增大最大流的边。
    
    求法：
    
    在残余网络上从源点开始dfs，从汇点开始反向dfs，标记到达的点，然后枚举满流边判断即可。
    
    若求过可行边，已经有了SCC，直接判断入点是否与源点在同一SCC中且出点是否与汇点在同一SCC中即可。
    
    考虑为什么两种算法是等价的，由于源点到入点一定有流，所以一定存在入点到源点的有流路径，等价得证。

16. 枚举阶乘方案时可以用next_permutation
```c
next_permutation(vec.begin(),vec.end());//得到下一个排列。
```
17. 网格图在相邻格子之间任意连边得到得是一个二分图，无奇环。在网格图上的构造，或者从网格图上抽象出来建的图里经常用到。
18. 对于一些问题边界的估计，常量不能忽略，最好写个简单的程序来计算边界。
19. 一道题卡20分钟就可以换了。看过题人数，不要作死上鬼畜做法。
20. 解线性同余方程
```c
p = a[1]*x[1]+w[1]
p = a[2]*x[2]+w[2]

换成a[1]*x[1]-a[2]*x[2]=w[2]-w[1]
用exgcd做
```
21. exgcd 解 ax+by=c得到的结果(x[0],y[0])是方程ax+by=gcd(a,b)的解，换算成原方程的解是(x[0]*c/gcd(a,b),y[0]*c/gcd(a,b))

22. f[i]g[n-i]的求和直接卷积。f[i]g[j+i]的求和可以令G[n-i]=g[i]后，转换成f[i]G[(n-j)-i]后卷积求和。

23. 在模p意义下，存在一个i:[1,p-1]到j:[0,p-2]的一一映射关系，（设g为p的原根）映射关系是g^j=i(mod p) .用这个映射可以把 H[i]G[j] (i*j=C）变换成卷积的形式。

24. 主席树求区间颜色种数的两种做法:[链接](https://my.oschina.net/u/4418085/blog/3740708)

    （1）依次插入n个数，插入第 i个数时，我们只要在把第 i个版本的主席树的第 i 位 +1 就可以了，表示多出一个数。
    可以记录每个数上一次出现的位置，在当前版本的主席树中，给当前位 +1 后，把上一次出现相同数的位置 −1，这样就不会被算重复了。
    然后对于 [left,right] 这样的区间询问，在第 right 个版本的线段树上查询 [left,right] 的和即可。
    （2）就是你直接把主席树第 i 个位置的权值 pre 设为这位的数上一次出现的位置。然后查询一个区间 [l,r] 的颜色数 其实就是查询区间[1,r] 有多少个 pre 值 小于 l
    重点就是动态查询前缀中 有多少个数 小于一个给定数，每次在主席树的第 r个版本上查权值主席树中 有多少个数小于 l就完事了。

25. **==的优先级高于位运算**

26. dfs记的递归。。。。。。。。

27. 二分图：最大独立集=点数-最小点覆盖，最小点覆盖=最大匹配。

28. 点的数量和边的数量别搞错了，特别是边的范围给的是 m< n*(n-1)/2, 边的大小开n^2。

29. meet in the mid ：在直接做复杂度不对的情况下，变换一下式子，预处理一部分的值(比如做个dp啥的)。

30. 主席树的修改操作最好每一步都新建点（如果直接修改在原来基础上，要想清楚关系）。

31. 对于一类单调性优化问题：i+1的答案决策点大于i的答案决策点（取到答案的位置），可以用分治做。[l,r],决策点区间[ql,qr]里暴力计算mid的决策点位置pos，然后[l,mid-1],决策点区间[ql,pos];[mid+1,r]，决策点区间[pos,qr]。  复杂度是O(决策区间长度*logn)

32. [1,n]的所有区间有一种排序方式：

    n=4时：

    |      |      |      | 4,4  |
    | ---- | ---- | ---- | ---- |
    |      |      | 3,3  | 3,4  |
    |      | 2,2  | 2,3  | 2,4  |
    | 1,1  | 1,2  | 1,3  | 1,4  |

    这种排序对树状数组很有用:

    - 以[x,y]为右下角的矩形包括了[n+1-x,y]的所有子区间
    - 以[x,y]为左上角的矩形包括了所有形如（l<=n+1-x, r>=y)的区间[l,r];

33. 竟然出现了函数名写漏这种错误。。。调函数的时候函数名别忘记写了。[这一发提交](https://codeforces.com/contest/1513/submission/112917726)

34. |x-y|可以看成数轴上点x到点y之间的距离。

35. 求两个集合A、B之间元素的贡献时，不一定要一次性求出集合B对A中每个元素的贡献。

    可以对称的A--->B,B---->A求两次贡献。

    比如集合A、B是线段的集合，在A中取一个线段，B中取一个线段，求两线段并的最大值。

    可以对每条A中的线段(l,r),求B中左端点小于等于l的右端点最大值，然后交换A、B再来一次。

36. 博弈问题先手必败状态相对好求一点（对于对方的每一次操作，想办法通过一次操作使全局状态回到一个等价的状态）：最经典的一个数n，每次可以取[1,P],那么n=k*p是必败态   对于先手每一次操作，后手都使这个数回到模p为0这个等价状态。

37. rand()最大只有3万多，取随机数用

    ```c
    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
    int rnd(int l, int r) {
        uniform_int_distribution<int> uni(l, r);
        return uni(rng);
    }
    ```

38. 求一个区间w的出现次数，可以主席树，也可以对每个数，记录出现位置，然后二分。

39. 对于完全没思路的题，可以想想暴力做法，从暴力做法入手做优化。

40. 有时候正这不好做，可以反方向思考。

41. void f(int a[10])传的是指针，因此对传的指针a用sizeof得到的不是数组的大小，是指针的大小。

42. windows下的对拍程序

```c++
#include<bits/stdc++.h>
using namespace std;
#define db double

int main()
{
	for(int i=1;i<=10000;i++)
	{
		system("data.exe");
		db s=clock();
		system("csg.exe < data.in > data.out");
		db t=clock();
		system("std.exe < data.in > std.out");
		
		if(system("fc data.out std.out"))
		{
			puts("WA");
			return 0;
		}
		else 
			printf("AC:%d %.2f ms\n",i,t-s);
	}
	return 0;
}
```

43. 并查集在合并过程中，可以维护每个点到根这条链上的信息。每次更新父节点后，当前点的信息合并上原父节点的信息。